# Generated by Django 4.2.13 on 2024-06-17 13:55

from django.db import migrations, models
import django.db.models.deletion

from projects.migration_utils import name_to_slug


def save_annotation_managing_group_as_context(apps, schema_editor):
    '''
    Save the project context for annotations based on the corresponding managing_group
    '''
    Project = apps.get_model('projects', 'Project')
    Annotation = apps.get_model('vre', 'Annotation')

    for obj in Annotation.objects.all():
        research_group = obj.managing_group
        # find the matching project (created by data migration in projects app)
        project = Project.objects.get(display_name=research_group.name)
        obj.context = project
        obj.save()

def save_collection_managing_group_as_context(apps, schema_editor):
    '''
    Save the project context for collections based on the corresponding managing_group

    This comes with data loss, as managing_group is many-to-many, while project context is
    not; we have to pick a single project.

    This is resolved in the following order of preference:
    1. Select the research group with matching name
    2. Select the only group that is not named "EDPOP VRE Research Group"
    3. Create a new project based on the collection name

    (The third case is a fallback, but this scenario does not occur in the production
    database.)

    After the migration, wider access to collections can be achieved by adding more 
    user groups to the project. This step is not automated.
    '''

    Project = apps.get_model('projects', 'Project')
    Collection = apps.get_model('vre', 'Collection')

    for obj in Collection.objects.all():
        matching_name = obj.managing_group.filter(name=obj.description)
        if matching_name.exists():
            research_group = matching_name.first()
            project = Project.objects.get(display_name=research_group.name)
        elif obj.managing_group.exclude(name='EDPOP VRE Research Group').count() == 1:
            research_group = obj.managing_group.exclude(name='EDPOP VRE Research Group').first()
            project = Project.objects.get(display_name=research_group.name)
        else:
            project = Project.objects.create(
                name=name_to_slug(obj.description),
                display_name=obj.description,
            )
            project.save()
        
        obj.context = project
        obj.save()


class Migration(migrations.Migration):

    dependencies = [
        ('projects', '0002_researchgroups_to_projects'),
        ('vre', '0005_alter_annotation_content_alter_annotation_id_and_more'),
    ]

    operations = [
        # create nullable fields
        migrations.AddField(
            model_name='annotation',
            name='context',
            field=models.ForeignKey(null=True, on_delete=django.db.models.deletion.CASCADE, to='projects.project'),
        ),
        migrations.AddField(
            model_name='collection',
            name='context',
            field=models.ForeignKey(null=True, on_delete=django.db.models.deletion.CASCADE, to='projects.project'),
        ),
        # fill with data
        migrations.RunPython(
            save_annotation_managing_group_as_context,
            reverse_code=migrations.RunPython.noop,
        ),
        migrations.RunPython(
            save_collection_managing_group_as_context,
            reverse_code=migrations.RunPython.noop,
        ),
        # make fields non-nullable
        migrations.AlterField(
            model_name='annotation',
            name='context',
            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='projects.project'),
        ),
        migrations.AlterField(
            model_name='collection',
            name='context',
            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='projects.project'),
        ),
    ]
